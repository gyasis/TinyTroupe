"""
Present Mental Faculty for TinyTroupe Agents

This module implements the Present Mental Faculty, which enables agents to use tools
for generating detailed documents (PRESENT mode) or conversational summaries (TALK mode)
and share them with other agents.
"""

import json
import textwrap
from typing import Dict, List, Optional, Any, Union

from tinytroupe.agent.mental_faculty import TinyMentalFaculty
from tinytroupe.tools.tool_orchestrator import (
    ToolOrchestrator, OutputMode, global_tool_orchestrator
)
import tinytroupe.utils as utils


class PresentMentalFaculty(TinyMentalFaculty):
    """
    Mental faculty that enables agents to use tools for document generation and sharing.
    
    This faculty provides three main capabilities:
    1. PRESENT: Generate detailed, structured documents using tools
    2. SUMMARIZE: Create conversational summaries of information
    3. SHARE: Share generated documents with other agents
    """
    
    def __init__(self, tool_orchestrator: ToolOrchestrator = None):
        super().__init__("Present and Share")
        
        if tool_orchestrator is None:
            self.tool_orchestrator = global_tool_orchestrator
        else:
            self.tool_orchestrator = tool_orchestrator
    
    def process_action(self, agent, action: dict) -> bool:
        """Process present-related actions."""
        action_type = action.get('type', '').upper()
        
        # Handle PRESENT actions for detailed document generation
        if action_type == "PRESENT":
            return self._process_present_action(agent, action)
        
        # Handle SUMMARIZE actions for conversational summaries
        elif action_type == "SUMMARIZE":
            return self._process_summarize_action(agent, action)
        
        # Handle SHARE actions for document sharing
        elif action_type == "SHARE":
            return self._process_share_action(agent, action)
        
        # Handle REFERENCE actions for citing shared documents
        elif action_type == "REFERENCE":
            return self._process_reference_action(agent, action)
        
        # Delegate to tool orchestrator for tool-specific actions
        else:
            return self.tool_orchestrator.process_tool_action(agent, action)
    
    def _process_present_action(self, agent, action: dict) -> bool:
        """
        Process PRESENT action to generate detailed documents.
        
        Expected action format:
        {
            "type": "PRESENT",
            "content": {
                "tool": "tool_name",
                "topic": "Document topic",
                "format": "markdown|docx|pdf",
                "template": "template_name (optional)",
                "parameters": {...} (tool-specific parameters)
            }
        }
        """
        try:
            content = action.get('content')
            if isinstance(content, str):
                content = utils.extract_json(content)
            
            tool_name = content.get('tool')
            topic = content.get('topic')
            doc_format = content.get('format', 'markdown')
            template = content.get('template')
            parameters = content.get('parameters', {})
            
            if not tool_name or not topic:
                agent.think("I need to specify both a tool and a topic for PRESENT action.")
                return False
            
            # Create enhanced action for the tool with present mode
            tool_action = {
                "type": "GENERATE_DOCUMENT",
                "output_mode": "present",
                "content": {
                    "topic": topic,
                    "format": doc_format,
                    "template": template,
                    **parameters
                }
            }
            
            # Process through tool orchestrator
            success = self.tool_orchestrator.process_tool_action(agent, tool_action)
            
            if success:
                agent.think(f"I have successfully generated a detailed document about '{topic}' using the {tool_name} tool.")
                
                # Store document reference in agent's semantic memory
                doc_reference = f"Document: {topic} (generated by {tool_name})"
                agent.store_memory(doc_reference)
                
                return True
            else:
                agent.think(f"I encountered an issue generating the document about '{topic}' with {tool_name}.")
                return False
                
        except Exception as e:
            agent.think(f"I had trouble processing the PRESENT action: {str(e)}")
            return False
    
    def _process_summarize_action(self, agent, action: dict) -> bool:
        """
        Process SUMMARIZE action to generate conversational summaries.
        
        Expected action format:
        {
            "type": "SUMMARIZE",
            "content": {
                "tool": "tool_name",
                "topic": "Topic to summarize",
                "source": "source_document_or_data",
                "style": "executive|technical|casual",
                "length": "brief|detailed"
            }
        }
        """
        try:
            content = action.get('content')
            if isinstance(content, str):
                content = utils.extract_json(content)
            
            tool_name = content.get('tool')
            topic = content.get('topic')
            source = content.get('source')
            style = content.get('style', 'casual')
            length = content.get('length', 'brief')
            
            if not tool_name or not topic:
                agent.think("I need to specify both a tool and a topic for SUMMARIZE action.")
                return False
            
            # Create enhanced action for the tool with talk mode
            tool_action = {
                "type": "GENERATE_SUMMARY",
                "output_mode": "talk",
                "content": {
                    "topic": topic,
                    "source": source,
                    "style": style,
                    "length": length
                }
            }
            
            # Process through tool orchestrator
            success = self.tool_orchestrator.process_tool_action(agent, tool_action)
            
            if success:
                agent.think(f"I have created a {style} summary about '{topic}' using the {tool_name} tool.")
                return True
            else:
                agent.think(f"I had difficulty creating the summary about '{topic}' with {tool_name}.")
                return False
                
        except Exception as e:
            agent.think(f"I encountered an error processing the SUMMARIZE action: {str(e)}")
            return False
    
    def _process_share_action(self, agent, action: dict) -> bool:
        """
        Process SHARE action to share documents with other agents.
        
        Expected action format:
        {
            "type": "SHARE",
            "content": {
                "document": "document_identifier",
                "recipients": ["agent1", "agent2"],
                "message": "optional sharing message"
            }
        }
        """
        try:
            content = action.get('content')
            if isinstance(content, str):
                content = utils.extract_json(content)
            
            document = content.get('document')
            recipients = content.get('recipients', [])
            message = content.get('message', '')
            
            if not document or not recipients:
                agent.think("I need to specify both a document and recipients for SHARE action.")
                return False
            
            # For now, simulate sharing by adding to agent's memory
            # In a full implementation, this would integrate with the document repository
            share_record = f"Shared document '{document}' with {', '.join(recipients)}"
            if message:
                share_record += f" with message: {message}"
            
            agent.store_memory(share_record)
            agent.think(f"I have shared the document '{document}' with {', '.join(recipients)}.")
            
            # In a real implementation, notify recipient agents
            # This would integrate with the TinyWorld environment
            
            return True
            
        except Exception as e:
            agent.think(f"I had trouble sharing the document: {str(e)}")
            return False
    
    def _process_reference_action(self, agent, action: dict) -> bool:
        """
        Process REFERENCE action to cite shared documents in conversations.
        
        Expected action format:
        {
            "type": "REFERENCE",
            "content": {
                "document": "document_identifier",
                "context": "how this document relates to current discussion"
            }
        }
        """
        try:
            content = action.get('content')
            if isinstance(content, str):
                content = utils.extract_json(content)
            
            document = content.get('document')
            context = content.get('context', '')
            
            if not document:
                agent.think("I need to specify a document to reference.")
                return False
            
            # Retrieve document information (simplified for now)
            reference_info = f"Referenced document: {document}"
            if context:
                reference_info += f" in context: {context}"
            
            agent.think(reference_info)
            
            return True
            
        except Exception as e:
            agent.think(f"I had trouble referencing the document: {str(e)}")
            return False
    
    def actions_definitions_prompt(self) -> str:
        """Define the actions available through this faculty."""
        prompt = """
        Present and Share Actions:
        - PRESENT: Generate a detailed, structured document using available tools. You must specify:
          * tool: The name of the tool to use for generation
          * topic: The subject matter for the document
          * format: The output format (markdown, docx, pdf)
          * template: Optional template name for formatting
          * parameters: Any tool-specific parameters needed
          
        - SUMMARIZE: Create a conversational summary using available tools. You must specify:
          * tool: The name of the tool to use for summarization
          * topic: The subject matter to summarize
          * source: Optional source document or data to summarize from
          * style: The summary style (executive, technical, casual)
          * length: The summary length (brief, detailed)
          
        - SHARE: Share a generated document with other agents. You must specify:
          * document: The identifier of the document to share
          * recipients: List of agent names to share with
          * message: Optional message to include with the sharing
          
        - REFERENCE: Cite a shared document in your current conversation. You must specify:
          * document: The identifier of the document to reference
          * context: How this document relates to the current discussion
        """
        
        # Add tool-specific actions (skip during agent creation when agent context isn't available)
        try:
            tool_prompt = self.tool_orchestrator.get_tool_definitions_prompt(None)
            return textwrap.dedent(prompt) + "\n" + tool_prompt
        except:
            # During agent initialization, just return the basic prompt
            return textwrap.dedent(prompt)
    
    def actions_constraints_prompt(self) -> str:
        """Define constraints for present and share actions."""
        prompt = """
        Present and Share Constraints:
        - When you PRESENT, always choose the most appropriate tool for the type of document needed
        - When you SUMMARIZE, tailor the style and length to your audience and context
        - Use PRESENT mode for formal documents that need to be referenced later
        - Use SUMMARIZE mode for quick updates or informal discussions
        - Always SHARE important documents with relevant team members
        - Use REFERENCE when discussing topics covered in existing shared documents
        - Include proper context when SHARING to help recipients understand the document's purpose
        - Store generated documents in your memory for future reference
        """
        
        # Add tool-specific constraints
        tool_constraints = self.tool_orchestrator.get_tool_constraints_prompt(None)  # Will be set by agent context
        
        return textwrap.dedent(prompt) + "\n" + tool_constraints
    
    def get_available_tools_info(self, agent) -> str:
        """Get information about tools available to this agent."""
        available_tools = self.tool_orchestrator.get_available_tools(agent)
        
        if not available_tools:
            return "No tools are currently available to you."
        
        info = f"You have access to {len(available_tools)} tools:\n"
        for tool in available_tools:
            info += f"- {tool.name}: {tool.description}\n"
        
        return info